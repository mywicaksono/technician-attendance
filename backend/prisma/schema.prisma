generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Role-based access control roles.
enum Role {
  TECHNICIAN
  SUPERVISOR
  ADMIN
}

/// User account state.
enum UserStatus {
  ACTIVE
  DISABLED
}

/// Append-only attendance event type.
enum EventType {
  CHECK_IN
  CHECK_OUT
}

/// Materialized session lifecycle state.
enum SessionStatus {
  OPEN
  CLOSED
  OVERRIDDEN
}

/// Final decision of server validation.
enum ValidationDecision {
  ACCEPTED
  REJECTED
}

/// Geofence status for accepted events (nullable for rejected events).
enum RangeStatus {
  IN_RANGE
  OUT_OF_RANGE
}

/// Rejection reason taxonomy (nullable for accepted events).
enum RejectReason {
  INVALID_QR
  REPLAY
  INVALID_SESSION
  MISSING_SELFIE
  OUT_OF_RANGE
}

model User {
  id           String     @id @default(uuid())
  email        String     @unique
  passwordHash String?
  ssoSubject   String?    @unique
  role         Role
  status       UserStatus @default(ACTIVE)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  /// One technician can register multiple client devices.
  devices               Device[]
  attendanceEvents      AttendanceEvent[]   @relation("AttendanceTechnician")
  sessionsAsTechnician  AttendanceSession[] @relation("SessionTechnician")
  auditLogs             AuditLog[]
  qrPayloadReplayEvents QrPayloadReplay[]

  @@map("users")
}

model Device {
  id           String   @id @default(uuid())
  technicianId String
  deviceUuid   String
  model        String?
  osVersion    String?
  appVersion   String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  technician       User              @relation(fields: [technicianId], references: [id])
  attendanceEvents AttendanceEvent[]

  @@unique([technicianId, deviceUuid])
  @@index([technicianId, updatedAt])
  @@map("devices")
}

model Site {
  id                String   @id @default(uuid())
  code              String   @unique
  name              String
  latitude          Decimal  @db.Decimal(10, 7)
  longitude         Decimal  @db.Decimal(10, 7)
  radiusMeters      Int
  qrRotationMinutes Int
  strictOutOfRange  Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  attendanceEvents   AttendanceEvent[]
  attendanceSessions AttendanceSession[]
  qrPayloadReplays   QrPayloadReplay[]

  @@index([name])
  @@map("sites")
}

model AttendanceEvent {
  id            String   @id @default(uuid())
  technicianId  String
  siteId        String
  deviceId      String?
  /// Client-generated UUID for idempotent retries.
  clientEventId String
  eventType     EventType

  /// ACCEPTED or REJECTED by server-side validation.
  decision ValidationDecision
  /// Geofence result for accepted events; null when rejected.
  rangeStatus RangeStatus?
  /// Rejection code when decision=REJECTED; null when accepted.
  rejectReason RejectReason?

  selfieObjectKey String
  /// Hash of full signed QR payload for auditability on CHECK_IN.
  qrPayloadHash String?
  qrNonce       String?
  qrIssuedAt    DateTime?
  qrExpiresAt   DateTime?
  lat           Decimal @db.Decimal(10, 7)
  lng           Decimal @db.Decimal(10, 7)
  accuracyMeters Decimal @db.Decimal(8, 2)

  /// Device-captured timestamp from client.
  capturedAtClient DateTime
  /// Server-side canonical timestamp for ordering/reporting.
  occurredAtServer DateTime @default(now())

  technician User               @relation("AttendanceTechnician", fields: [technicianId], references: [id])
  site       Site               @relation(fields: [siteId], references: [id])
  device     Device?            @relation(fields: [deviceId], references: [id])
  sessionsAsCheckIn  AttendanceSession[] @relation("SessionCheckInEvent")
  sessionsAsCheckOut AttendanceSession[] @relation("SessionCheckOutEvent")
  acceptedQrReplays  QrPayloadReplay[]   @relation("ReplayAcceptedEvent")

  /// Enforces idempotency per technician.
  @@unique([technicianId, clientEventId])
  /// Reporting indexes.
  @@index([technicianId, occurredAtServer])
  @@index([siteId, occurredAtServer])
  @@index([decision, occurredAtServer])
  @@index([rangeStatus, occurredAtServer])
  @@index([eventType, occurredAtServer])
  @@map("attendance_event")
}

model AttendanceSession {
  id              String        @id @default(uuid())
  technicianId    String
  siteId          String
  checkInEventId  String
  checkOutEventId String?
  status          SessionStatus @default(OPEN)
  startedAt       DateTime
  endedAt         DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  technician    User             @relation("SessionTechnician", fields: [technicianId], references: [id])
  site          Site             @relation(fields: [siteId], references: [id])
  checkInEvent  AttendanceEvent  @relation("SessionCheckInEvent", fields: [checkInEventId], references: [id])
  checkOutEvent AttendanceEvent? @relation("SessionCheckOutEvent", fields: [checkOutEventId], references: [id])

  /// One event can only open one materialized session.
  @@unique([checkInEventId])
  /// One check-out event can only close one materialized session.
  @@unique([checkOutEventId])
  /// Active session lookup and reporting.
  @@index([technicianId, status, startedAt])
  @@index([siteId, status, startedAt])
  @@index([status, updatedAt])
  @@map("attendance_session")
}

model QrPayloadReplay {
  id              String   @id @default(uuid())
  siteId          String
  nonce           String
  issuedAt        DateTime
  expiresAt       DateTime
  firstSeenAt     DateTime @default(now())
  acceptedEventId String?
  seenByUserId    String?

  site          Site             @relation(fields: [siteId], references: [id])
  acceptedEvent AttendanceEvent? @relation("ReplayAcceptedEvent", fields: [acceptedEventId], references: [id])
  seenByUser    User?            @relation(fields: [seenByUserId], references: [id])

  /// Anti-replay protection for signed QR payloads.
  @@unique([siteId, nonce])
  @@index([expiresAt])
  @@map("qr_payload_replay")
}

model AuditLog {
  id         String   @id @default(uuid())
  actorId    String?
  action     String
  entityName String
  entityId   String
  reason     String?
  metadata   Json?
  createdAt  DateTime @default(now())

  actor User? @relation(fields: [actorId], references: [id])

  @@index([entityName, entityId, createdAt])
  @@index([actorId, createdAt])
  @@map("audit_log")
}
